# GoReport 系统测试计划

**文档版本:** 1.0  
**创建日期:** 2026-02-14  
**基于文档:** all-requirements.md (22 个能力规格 + 19 个已归档变更)

---

## 目录

1. [文档概述](#1-文档概述)
2. [测试范围](#2-测试范围)
3. [测试策略](#3-测试策略)
4. [测试环境](#4-测试环境)
5. [测试数据准备](#5-测试数据准备)
6. [测试用例](#6-测试用例)
   - 6.1 [认证与授权测试](#61-认证与授权测试)
   - 6.2 [数据源管理测试](#62-数据源管理测试)
   - 6.3 [数据集管理测试](#63-数据集管理测试)
   - 6.4 [报表设计器测试](#64-报表设计器测试)
   - 6.5 [报表渲染与预览测试](#65-报表渲染与预览测试)
   - 6.6 [报表导出测试](#66-报表导出测试)
   - 6.7 [BI 仪表盘测试](#67-bi-仪表盘测试)
   - 6.8 [图表编辑器测试](#68-图表编辑器测试)
   - 6.9 [查询缓存测试](#69-查询缓存测试)
   - 6.10 [前端功能可用性测试](#610-前端功能可用性测试)
   - 6.11 [系统集成与兼容性测试](#611-系统集成与兼容性测试)
   - 6.12 [性能测试](#612-性能测试)
   - 6.13 [安全测试](#613-安全测试)
7. [测试执行计划](#7-测试执行计划)
8. [缺陷管理](#8-缺陷管理)
9. [测试报告](#9-测试报告)

---

## 1. 文档概述

### 1.1 目的

本测试计划旨在为 GoReport 系统提供全面的测试指导，确保系统功能、性能、安全性和兼容性满足业务需求。测试将覆盖 22 个能力规格定义的所有需求。

### 1.2 适用范围

本测试计划适用于：
- GoReport 系统的功能验证测试
- API 接口测试
- 前端 UI 测试
- 性能测试
- 安全测试
- 兼容性测试

### 1.3 参考文档

| 文档 | 版本 | 描述 |
|------|------|------|
| all-requirements.md | 1.0 | 系统需求规格文档 |
| AGENTS.md | - | 项目开发指南 |
| README.md | - | 项目概述 |
| openspec/specs/* | - | 能力规格定义 |

### 1.4 术语定义

| 术语 | 定义 |
|------|------|
| JWT | JSON Web Token，用于身份认证的令牌 |
| 租户 | 多租户系统中的独立租户单位 |
| 数据源 | 数据库连接配置 |
| 数据集 | 基于 SQL/API 的数据定义 |
| 维度 | 用于分组/分类的数据字段 |
| 度量 | 用于聚合计算的数值字段 |
| 计算字段 | 通过表达式计算得出的字段 |

---

## 2. 测试范围

### 2.1 功能测试范围

| 模块 | 子模块 | 优先级 | 测试类型 |
|------|--------|--------|----------|
| **认证与授权** | JWT 认证 | P0 | 功能/安全 |
| | Token 生成 | P0 | 功能 |
| | Claim 映射 | P0 | 功能 |
| | 密码哈希 | P0 | 安全 |
| **数据源管理** | CRUD 操作 | P0 | 功能 |
| | 连接测试 | P0 | 功能 |
| | 元数据查询 | P0 | 功能 |
| | 租户隔离 | P0 | 功能/安全 |
| | SSH 隧道 | P1 | 功能 |
| | 运行时控制 | P1 | 功能 |
| **数据集管理** | CRUD 操作 | P0 | 功能 |
| | 字段配置 | P0 | 功能 |
| | 计算字段 | P0 | 功能 |
| | 批量操作 | P1 | 功能 |
| | 查询安全 | P0 | 安全 |
| | 编辑器工作流 | P1 | 功能 |
| **报表设计器** | Canvas 设计 | P0 | 功能/UI |
| | 数据绑定 | P0 | 功能 |
| | 表达式编辑器 | P1 | 功能/UI |
| | 保存/加载 | P0 | 功能 |
| **报表渲染** | 数据渲染 | P0 | 功能 |
| | 分页 | P1 | 功能 |
| | 打印预览 | P1 | 功能/UI |
| **报表导出** | PDF 导出 | P1 | 功能 |
| | Excel 导出 | P1 | 功能 |
| | 参数化导出 | P1 | 功能 |
| **BI 仪表盘** | 组件拖放 | P0 | 功能/UI |
| | 数据绑定 | P0 | 功能 |
| | 图层管理 | P1 | 功能/UI |
| | 预览模式 | P1 | 功能 |
| **图表编辑器** | 图表类型选择 | P0 | 功能/UI |
| | ECharts 集成 | P0 | 功能 |
| | 数据源配置 | P0 | 功能 |
| | 实时预览 | P1 | 功能/UI |
| **查询缓存** | Redis 缓存 | P1 | 功能/性能 |
| | 降级机制 | P1 | 功能 |
| | 租户隔离 | P0 | 功能/安全 |
| **前端可用性** | 核心入口 | P0 | 功能/UI |
| | 错误处理 | P0 | 功能 |
| **系统集成** | 迁移兼容 | P1 | 兼容性 |
| | 嵌入式集成 | P1 | 功能 |
| | CORS 配置 | P1 | 功能/安全 |

### 2.2 非功能测试范围

| 测试类型 | 范围 | 优先级 |
|----------|------|--------|
| **性能测试** | 大数据量查询、报表渲染、仪表盘加载 | P1 |
| **安全测试** | 认证授权、SQL 注入、XSS、租户隔离 | P0 |
| **兼容性测试** | 浏览器兼容、响应式布局 | P1 |
| **可用性测试** | UI 交互、错误提示 | P1 |

### 2.3 不在测试范围内

- 第三方库（ECharts、Monaco Editor）内部功能
- 操作系统级别的安全测试
- 网络层面的压力测试
- 硬件兼容性测试

---

## 3. 测试策略

### 3.1 测试层次

```
┌─────────────────────────────────────────────────────┐
│                    E2E 测试                          │
│           (端到端业务流程测试)                        │
├─────────────────────────────────────────────────────┤
│                  集成测试                            │
│        (API 集成、数据库集成、缓存集成)               │
├─────────────────────────────────────────────────────┤
│                  组件测试                            │
│          (前端组件、后端服务单元)                     │
├─────────────────────────────────────────────────────┤
│                  单元测试                            │
│            (函数、方法级别测试)                       │
└─────────────────────────────────────────────────────┘
```

### 3.2 测试方法

| 测试类型 | 方法 | 工具 | 覆盖率目标 |
|----------|------|------|------------|
| 单元测试 | 白盒 | Go test, Vitest | ≥ 80% |
| API 测试 | 黑盒 | Postman, curl | 100% API |
| 功能测试 | 黑盒 | 手工 + 自动化 | 100% P0 用例 |
| UI 测试 | 黑盒 | Playwright | 核心流程 |
| 性能测试 | 灰盒 | k6, JMeter | 关键场景 |
| 安全测试 | 灰盒 | OWASP ZAP, SQLMap | 认证授权 |

### 3.3 测试优先级定义

| 优先级 | 定义 | 覆盖要求 |
|--------|------|----------|
| **P0** | 核心功能，阻塞性问题 | 100% 执行 |
| **P1** | 重要功能，影响用户体验 | 80% 执行 |
| **P2** | 次要功能，边界场景 | 50% 执行 |
| **P3** | 可选功能，探索性测试 | 按需执行 |

### 3.4 测试入口/出口准则

#### 入口准则

- [ ] 代码已提交并通过 CI 基础检查
- [ ] 开发单元测试通过
- [ ] 测试环境已部署最新版本
- [ ] 测试数据已准备完毕
- [ ] 测试用例已评审

#### 出口准则

- [ ] P0 用例 100% 通过
- [ ] P1 用例 ≥ 95% 通过
- [ ] 无未解决的 P0/P1 缺陷
- [ ] 性能指标满足要求
- [ ] 安全测试无高危漏洞

---

## 4. 测试环境

### 4.1 环境配置

| 环境 | 用途 | 配置 |
|------|------|------|
| **开发环境** | 开发自测 | Docker Compose 本地部署 |
| **测试环境** | 功能测试 | Kubernetes 集群 |
| **预发布环境** | UAT 测试 | 与生产配置一致 |
| **生产环境** | 线上运行 | 高可用部署 |

### 4.2 测试环境硬件要求

| 组件 | 最低配置 | 推荐配置 |
|------|----------|----------|
| 应用服务器 | 2C4G | 4C8G |
| MySQL | 2C4G, 50GB SSD | 4C8G, 100GB SSD |
| Redis | 1C2G | 2C4G |
| 测试机 | 4C8G | 8C16G |

### 4.3 软件版本要求

| 软件 | 版本 |
|------|------|
| Go | 1.22+ |
| Node.js | 18+ |
| MySQL | 8.0+ |
| Redis | 6.0+ |
| Docker | 24.0+ |
| 浏览器 | Chrome 100+, Firefox 100+, Safari 15+ |

### 4.4 环境部署命令

```bash
# 启动测试环境
make dev

# 初始化测试数据库
mysql -h localhost -u root -proot goreport < backend/db/init.sql

# 运行后端测试
cd backend && go test ./... -cover

# 运行前端测试
cd frontend && npm run test:run
```

---

## 5. 测试数据准备

### 5.1 用户数据

| 用户类型 | 用户名 | 密码 | 租户 | 角色 |
|----------|--------|------|------|------|
| 管理员 | admin | Admin@123 | tenant-admin | admin |
| 普通用户 | user1 | User1@123 | tenant-1 | user |
| 普通用户 | user2 | User2@123 | tenant-2 | user |
| 只读用户 | viewer | Viewer@123 | tenant-1 | viewer |

### 5.2 数据源数据

| 数据源名称 | 类型 | 主机 | 数据库 | 用途 |
|------------|------|------|--------|------|
| test-mysql | MySQL | localhost:3306 | test_db | 功能测试 |
| test-mysql-ssh | MySQL | 通过 SSH 隧道 | test_db | SSH 隧道测试 |
| test-postgres | PostgreSQL | localhost:5432 | test_db | 多类型测试 |

### 5.3 业务数据

```sql
-- 测试表：订单表
CREATE TABLE test_orders (
    id VARCHAR(36) PRIMARY KEY,
    order_no VARCHAR(50),
    customer_name VARCHAR(100),
    product_name VARCHAR(100),
    quantity INT,
    price DECIMAL(10,2),
    total_amount DECIMAL(10,2),
    order_date DATE,
    status VARCHAR(20),
    tenant_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 插入测试数据（10000条）
INSERT INTO test_orders (id, order_no, customer_name, product_name, quantity, price, total_amount, order_date, status, tenant_id)
SELECT 
    UUID(),
    CONCAT('ORD', LPAD(n, 6, '0')),
    ELT(1 + FLOOR(RAND() * 10), '张三', '李四', '王五', '赵六', '钱七', '孙八', '周九', '吴十', '郑十一', '王十二'),
    ELT(1 + FLOOR(RAND() * 5), '产品A', '产品B', '产品C', '产品D', '产品E'),
    FLOOR(1 + RAND() * 100),
    ROUND(10 + RAND() * 990, 2),
    0,
    DATE_SUB(CURDATE(), INTERVAL FLOOR(RAND() * 365) DAY),
    ELT(1 + FLOOR(RAND() * 3), '已完成', '进行中', '已取消'),
    ELT(1 + FLOOR(RAND() * 2), 'tenant-1', 'tenant-2')
FROM (
    SELECT a.N + b.N * 10 + c.N * 100 + d.N * 1000 + 1 AS n
    FROM (SELECT 0 AS N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) a
    ,(SELECT 0 AS N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) b
    ,(SELECT 0 AS N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) c
    ,(SELECT 0 AS N UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9) d
) numbers;

-- 更新 total_amount
UPDATE test_orders SET total_amount = quantity * price;
```

### 5.4 测试报表配置

```json
{
  "reportId": "test-report-001",
  "name": "销售订单报表",
  "type": "canvas",
  "cells": [
    {
      "id": "cell-1",
      "row": 0,
      "col": 0,
      "value": "订单编号",
      "style": {"fontWeight": "bold"}
    },
    {
      "id": "cell-2",
      "row": 0,
      "col": 1,
      "binding": {
        "type": "dataset",
        "datasetId": "dataset-001",
        "field": "order_no"
      }
    }
  ]
}
```

---

## 6. 测试用例

### 6.1 认证与授权测试

#### 6.1.1 登录功能测试

| 用例ID | TC-AUTH-001 |
|--------|-------------|
| **用例名称** | 用户登录 - 正常场景 |
| **优先级** | P0 |
| **前置条件** | 用户已注册 |
| **测试步骤** | 1. 打开登录页面<br>2. 输入有效用户名和密码<br>3. 点击登录按钮 |
| **预期结果** | 1. 登录成功，跳转到首页<br>2. 响应包含有效 JWT Token<br>3. Token 包含 userId、username、roles、tenantId<br>4. 返回状态码 200 |
| **测试数据** | 用户名: user1, 密码: User1@123 |

| 用例ID | TC-AUTH-002 |
|--------|-------------|
| **用例名称** | 用户登录 - 无效密码 |
| **优先级** | P0 |
| **前置条件** | 用户已注册 |
| **测试步骤** | 1. 打开登录页面<br>2. 输入有效用户名和错误密码<br>3. 点击登录按钮 |
| **预期结果** | 1. 登录失败<br>2. 返回状态码 401<br>3. 返回错误消息"用户名或密码错误" |
| **测试数据** | 用户名: user1, 密码: wrongpassword |

| 用例ID | TC-AUTH-003 |
|--------|-------------|
| **用例名称** | 用户登录 - 用户不存在 |
| **优先级** | P0 |
| **前置条件** | 无 |
| **测试步骤** | 1. 打开登录页面<br>2. 输入不存在的用户名和密码<br>3. 点击登录按钮 |
| **预期结果** | 1. 登录失败<br>2. 返回状态码 401<br>3. 返回错误消息"用户名或密码错误" |
| **测试数据** | 用户名: nonexistent, 密码: anypassword |

| 用例ID | TC-AUTH-004 |
|--------|-------------|
| **用例名称** | 用户登录 - 空用户名/密码 |
| **优先级** | P1 |
| **前置条件** | 无 |
| **测试步骤** | 1. 打开登录页面<br>2. 留空用户名或密码<br>3. 点击登录按钮 |
| **预期结果** | 1. 表单验证失败<br>2. 显示字段必填提示<br>3. 不发送登录请求 |

| 用例ID | TC-AUTH-005 |
|--------|-------------|
| **用例名称** | 用户登录 - SQL 注入尝试 |
| **优先级** | P0 |
| **前置条件** | 无 |
| **测试步骤** | 1. 打开登录页面<br>2. 输入 SQL 注入字符串<br>3. 点击登录按钮 |
| **预期结果** | 1. 登录失败<br>2. 返回状态码 401<br>3. 无 SQL 错误暴露<br>4. 系统安全不受影响 |
| **测试数据** | 用户名: ' OR '1'='1, 密码: ' OR '1'='1 |

#### 6.1.2 Token 验证测试

| 用例ID | TC-AUTH-006 |
|--------|-------------|
| **用例名称** | 有效 Token 访问受保护 API |
| **优先级** | P0 |
| **前置条件** | 用户已登录获取有效 Token |
| **测试步骤** | 1. 在请求头添加有效 JWT Token<br>2. 访问受保护的 API（如 /api/v1/datasources） |
| **预期结果** | 1. 请求成功<br>2. 返回状态码 200<br>3. 返回用户租户的数据 |

| 用例ID | TC-AUTH-007 |
|--------|-------------|
| **用例名称** | 无 Token 访问受保护 API |
| **优先级** | P0 |
| **前置条件** | 无 |
| **测试步骤** | 1. 不添加 Authorization 头<br>2. 访问受保护的 API |
| **预期结果** | 1. 请求被拒绝<br>2. 返回状态码 401<br>3. 返回错误消息"未授权访问" |

| 用例ID | TC-AUTH-008 |
|--------|-------------|
| **用例名称** | 过期 Token 访问受保护 API |
| **优先级** | P0 |
| **前置条件** | 准备一个已过期的 JWT Token |
| **测试步骤** | 1. 在请求头添加过期 Token<br>2. 访问受保护的 API |
| **预期结果** | 1. 请求被拒绝<br>2. 返回状态码 401<br>3. 返回错误消息"Token 已过期" |

| 用例ID | TC-AUTH-009 |
|--------|-------------|
| **用例名称** | 篡改 Token 访问受保护 API |
| **优先级** | P0 |
| **前置条件** | 准备一个被篡改的 JWT Token |
| **测试步骤** | 1. 修改 Token 的 payload 部分<br>2. 访问受保护的 API |
| **预期结果** | 1. 请求被拒绝<br>2. 返回状态码 401<br>3. 返回错误消息"无效 Token" |

| 用例ID | TC-AUTH-010 |
|--------|-------------|
| **用例名称** | 健康检查端点无需认证 |
| **优先级** | P1 |
| **前置条件** | 无 |
| **测试步骤** | 1. 不添加任何认证信息<br>2. 访问 /health 端点 |
| **预期结果** | 1. 请求成功<br>2. 返回状态码 200<br>3. 返回数据库和服务状态 |

#### 6.1.3 Token 通过查询参数传递

| 用例ID | TC-AUTH-011 |
|--------|-------------|
| **用例名称** | 通过 URL 参数传递 Token |
| **优先级** | P1 |
| **前置条件** | 用户已登录获取有效 Token |
| **测试步骤** | 1. 构造 URL 带有 token 参数<br>2. 访问嵌入页面 |
| **预期结果** | 1. 请求成功<br>2. Token 被正确解析<br>3. 页面正常渲染 |

#### 6.1.4 登出功能测试

| 用例ID | TC-AUTH-012 |
|--------|-------------|
| **用例名称** | 用户登出 - 正常场景 |
| **优先级** | P0 |
| **前置条件** | 用户已登录 |
| **测试步骤** | 1. 携带有效 Token 调用登出 API<br>2. 使用相同 Token 再次访问 |
| **预期结果** | 1. 登出成功<br>2. Token 被失效<br>3. 再次访问返回 401 |

---

### 6.2 数据源管理测试

#### 6.2.1 数据源 CRUD 测试

| 用例ID | TC-DS-001 |
|--------|-------------|
| **用例名称** | 创建数据源 - MySQL 正常场景 |
| **优先级** | P0 |
| **前置条件** | 用户已登录 |
| **测试步骤** | 1. 调用 POST /api/v1/datasources<br>2. 提交完整的数据源配置 |
| **请求体** | ```json {"name":"test-mysql","type":"mysql","host":"localhost","port":3306,"database":"test_db","username":"root","password":"root"}``` |
| **预期结果** | 1. 返回状态码 201<br>2. 返回创建的数据源（不含密码）<br>3. 数据源 ID 自动生成<br>4. 数据源出现在列表中 |

| 用例ID | TC-DS-002 |
|--------|-------------|
| **用例名称** | 创建数据源 - 缺少必填字段 |
| **优先级** | P0 |
| **前置条件** | 用户已登录 |
| **测试步骤** | 1. 调用 POST /api/v1/datasources<br>2. 提交缺少 host 字段的配置 |
| **请求体** | ```json {"name":"test-mysql","type":"mysql","port":3306,"database":"test_db"}``` |
| **预期结果** | 1. 返回状态码 400<br>2. 返回字段级错误信息<br>3. 数据源未创建 |

| 用例ID | TC-DS-003 |
|--------|-------------|
| **用例名称** | 创建数据源 - 不支持的类型 |
| **优先级** | P1 |
| **前置条件** | 用户已登录 |
| **测试步骤** | 1. 调用 POST /api/v1/datasources<br>2. 提交不支持的数据源类型 |
| **请求体** | ```json {"name":"test-oracle","type":"oracle","host":"localhost","port":1521}``` |
| **预期结果** | 1. 返回状态码 400<br>2. 返回"不支持的数据源类型"错误 |

| 用例ID | TC-DS-004 |
|--------|-------------|
| **用例名称** | 列出数据源 - 正常场景 |
| **优先级** | P0 |
| **前置条件** | 用户已登录，租户内有多个数据源 |
| **测试步骤** | 1. 调用 GET /api/v1/datasources |
| **预期结果** | 1. 返回状态码 200<br>2. 返回当前租户的所有数据源<br>3. 不包含其他租户的数据源<br>4. 密码字段不返回 |

| 用例ID | TC-DS-005 |
|--------|-------------|
| **用例名称** | 更新数据源 - 正常场景 |
| **优先级** | P0 |
| **前置条件** | 数据源已存在 |
| **测试步骤** | 1. 调用 PUT /api/v1/datasources/{id}<br>2. 提交更新后的配置 |
| **预期结果** | 1. 返回状态码 200<br>2. 返回更新后的数据源<br>3. 更改已持久化 |

| 用例ID | TC-DS-006 |
|--------|-------------|
| **用例名称** | 删除数据源 - 正常场景 |
| **优先级** | P0 |
| **前置条件** | 数据源已存在且未被引用 |
| **测试步骤** | 1. 调用 DELETE /api/v1/datasources/{id} |
| **预期结果** | 1. 返回状态码 200<br>2. 数据源被软删除<br>3. 数据源不再出现在列表中 |

| 用例ID | TC-DS-007 |
|--------|-------------|
| **用例名称** | 删除数据源 - 被数据集引用 |
| **优先级** | P1 |
| **前置条件** | 数据源被数据集引用 |
| **测试步骤** | 1. 调用 DELETE /api/v1/datasources/{id} |
| **预期结果** | 1. 返回状态码 409<br>2. 返回引用该数据集的列表<br>3. 数据源未被删除 |

#### 6.2.2 数据源连接测试

| 用例ID | TC-DS-008 |
|--------|-------------|
| **用例名称** | 连接测试 - 成功 |
| **优先级** | P0 |
| **前置条件** | 数据源配置正确 |
| **测试步骤** | 1. 调用 POST /api/v1/datasources/{id}/test |
| **预期结果** | 1. 返回状态码 200<br>2. 返回 {"success": true}<br>3. 返回连接耗时 |

| 用例ID | TC-DS-009 |
|--------|-------------|
| **用例名称** | 连接测试 - 无效凭据 |
| **优先级** | P0 |
| **前置条件** | 数据源密码错误 |
| **测试步骤** | 1. 调用 POST /api/v1/datasources/{id}/test |
| **预期结果** | 1. 返回状态码 200<br>2. 返回 {"success": false, "message": "Access denied..."}<br>3. 返回诊断错误信息 |

| 用例ID | TC-DS-010 |
|--------|-------------|
| **用例名称** | 连接测试 - 网络不通 |
| **优先级** | P1 |
| **前置条件** | 数据源主机不可达 |
| **测试步骤** | 1. 调用 POST /api/v1/datasources/{id}/test |
| **预期结果** | 1. 返回状态码 200<br>2. 返回 {"success": false, "message": "Connection timeout..."} |

#### 6.2.3 元数据查询测试

| 用例ID | TC-DS-011 |
|--------|-------------|
| **用例名称** | 查询表列表 - 正常场景 |
| **优先级** | P0 |
| **前置条件** | 数据源连接正常 |
| **测试步骤** | 1. 调用 GET /api/v1/datasources/{id}/tables |
| **预期结果** | 1. 返回状态码 200<br>2. 返回所有基表列表<br>3. 每个表包含 name 和可选的 comment |

| 用例ID | TC-DS-012 |
|--------|-------------|
| **用例名称** | 查询字段列表 - 正常场景 |
| **优先级** | P0 |
| **前置条件** | 数据源连接正常 |
| **测试步骤** | 1. 调用 GET /api/v1/datasources/{id}/tables/{table}/fields |
| **预期结果** | 1. 返回状态码 200<br>2. 返回字段列表<br>3. 每个字段包含 name、type、nullable 等信息 |

#### 6.2.4 租户隔离测试

| 用例ID | TC-DS-013 |
|--------|-------------|
| **用例名称** | 跨租户访问数据源 - 被拒绝 |
| **优先级** | P0 |
| **前置条件** | user1 (tenant-1) 已登录，tenant-2 有数据源 ds-2 |
| **测试步骤** | 1. user1 尝试访问 GET /api/v1/datasources/{ds-2-id} |
| **预期结果** | 1. 返回状态码 403<br>2. 返回错误消息"无权访问该资源" |

| 用例ID | TC-DS-014 |
|--------|-------------|
| **用例名称** | 数据源列表仅返回当前租户数据 |
| **优先级** | P0 |
| **前置条件** | 多租户数据已准备 |
| **测试步骤** | 1. user1 调用 GET /api/v1/datasources |
| **预期结果** | 1. 仅返回 tenant-1 的数据源<br>2. 不包含其他租户的数据源 |

#### 6.2.5 SSH 隧道连接测试

| 用例ID | TC-DS-015 |
|--------|-------------|
| **用例名称** | SSH 隧道 - 密码认证 |
| **优先级** | P1 |
| **前置条件** | SSH 服务器可访问 |
| **测试步骤** | 1. 创建带 SSH 隧道的数据源<br>2. 配置 SSH 密码认证<br>3. 测试连接 |
| **预期结果** | 1. SSH 隧道建立成功<br>2. 数据源连接成功 |

| 用例ID | TC-DS-016 |
|--------|-------------|
| **用例名称** | SSH 隧道 - 密钥认证 |
| **优先级** | P1 |
| **前置条件** | SSH 服务器可访问，私钥已准备 |
| **测试步骤** | 1. 创建带 SSH 隧道的数据源<br>2. 配置 SSH 私钥认证<br>3. 测试连接 |
| **预期结果** | 1. SSH 隧道建立成功<br>2. 数据源连接成功 |

#### 6.2.6 运行时控制测试

| 用例ID | TC-DS-017 |
|--------|-------------|
| **用例名称** | 设置最大连接数 |
| **优先级** | P1 |
| **前置条件** | 数据源已创建 |
| **测试步骤** | 1. 更新数据源设置 maxConnections=10<br>2. 执行多个并发查询 |
| **预期结果** | 1. 配置保存成功<br>2. 并发连接数不超过设置值 |

| 用例ID | TC-DS-018 |
|--------|-------------|
| **用例名称** | 设置查询超时 |
| **优先级** | P1 |
| **前置条件** | 数据源已创建 |
| **测试步骤** | 1. 更新数据源设置 queryTimeout=5s<br>2. 执行耗时超过 5s 的查询 |
| **预期结果** | 1. 配置保存成功<br>2. 查询在 5s 后超时返回错误 |

---

### 6.3 数据集管理测试

#### 6.3.1 数据集 CRUD 测试

| 用例ID | TC-DM-001 |
|--------|-------------|
| **用例名称** | 创建 SQL 数据集 - 正常场景 |
| **优先级** | P0 |
| **前置条件** | 数据源已创建 |
| **测试步骤** | 1. 调用 POST /api/v1/datasets<br>2. 提交 SQL 数据集配置 |
| **请求体** | ```json {"name":"订单数据集","type":"sql","datasourceId":"ds-001","query":"SELECT * FROM test_orders WHERE tenant_id = ?"}``` |
| **预期结果** | 1. 返回状态码 201<br>2. 字段自动提取<br>3. 返回创建的数据集及字段列表 |

| 用例ID | TC-DM-002 |
|--------|-------------|
| **用例名称** | 创建数据集 - 无效 SQL |
| **优先级** | P0 |
| **前置条件** | 数据源已创建 |
| **测试步骤** | 1. 调用 POST /api/v1/datasets<br>2. 提交语法错误的 SQL |
| **预期结果** | 1. 返回状态码 400<br>2. 返回 SQL 语法错误信息<br>3. 数据集未创建 |

| 用例ID | TC-DM-003 |
|--------|-------------|
| **用例名称** | 创建数据集 - 危险 SQL 被拒绝 |
| **优先级** | P0 |
| **前置条件** | 数据源已创建 |
| **测试步骤** | 1. 调用 POST /api/v1/datasets<br>2. 提交包含 DROP/DELETE 的 SQL |
| **预期结果** | 1. 返回状态码 400<br>2. 返回"不安全的 SQL 操作"错误 |

| 用例ID | TC-DM-004 |
|--------|-------------|
| **用例名称** | 列出数据集 - 分页 |
| **优先级** | P0 |
| **前置条件** | 多个数据集已创建 |
| **测试步骤** | 1. 调用 GET /api/v1/datasets?page=1&pageSize=10 |
| **预期结果** | 1. 返回状态码 200<br>2. 返回第一页数据<br>3. 返回总数和分页信息 |

| 用例ID | TC-DM-005 |
|--------|-------------|
| **用例名称** | 获取数据集详情 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 GET /api/v1/datasets/{id} |
| **预期结果** | 1. 返回状态码 200<br>2. 返回完整数据集配置<br>3. 包含所有字段信息 |

| 用例ID | TC-DM-006 |
|--------|-------------|
| **用例名称** | 更新数据集 - 查询更改后重新提取字段 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 PUT /api/v1/datasets/{id}<br>2. 修改 SQL 查询 |
| **预期结果** | 1. 返回状态码 200<br>2. 字段列表已更新<br>3. 新字段被提取 |

| 用例ID | TC-DM-007 |
|--------|-------------|
| **用例名称** | 删除数据集 - 有引用时返回冲突 |
| **优先级** | P1 |
| **前置条件** | 数据集被报表引用 |
| **测试步骤** | 1. 调用 DELETE /api/v1/datasets/{id} |
| **预期结果** | 1. 返回状态码 409<br>2. 返回引用该数据集的报表列表 |

#### 6.3.2 数据集查询测试

| 用例ID | TC-DM-008 |
|--------|-------------|
| **用例名称** | 查询数据集数据 - 正常场景 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 POST /api/v1/datasets/{id}/data |
| **预期结果** | 1. 返回状态码 200<br>2. 返回数据数组<br>3. 返回总数和执行时间 |

| 用例ID | TC-DM-009 |
|--------|-------------|
| **用例名称** | 查询数据集数据 - 带过滤 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 POST /api/v1/datasets/{id}/data<br>2. 添加过滤条件 |
| **请求体** | ```json {"filters":[{"field":"status","operator":"eq","value":"已完成"}]}``` |
| **预期结果** | 1. 返回过滤后的数据<br>2. 仅包含 status="已完成" 的记录 |

| 用例ID | TC-DM-010 |
|--------|-------------|
| **用例名称** | 查询数据集数据 - 带排序 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 POST /api/v1/datasets/{id}/data<br>2. 添加排序条件 |
| **请求体** | ```json {"sortBy":"order_date","sortOrder":"desc"}``` |
| **预期结果** | 1. 返回按 order_date 降序排列的数据 |

| 用例ID | TC-DM-011 |
|--------|-------------|
| **用例名称** | 查询数据集数据 - 带分页 |
| **优先级** | P0 |
| **前置条件** | 数据集有大量数据 |
| **测试步骤** | 1. 调用 POST /api/v1/datasets/{id}/data<br>2. 添加分页参数 |
| **请求体** | ```json {"page":2,"pageSize":50}``` |
| **预期结果** | 1. 返回第 2 页的 50 条数据<br>2. 返回总数 |

| 用例ID | TC-DM-012 |
|--------|-------------|
| **用例名称** | 数据集预览 - 返回前 100 行 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 GET /api/v1/datasets/{id}/preview |
| **预期结果** | 1. 返回状态码 200<br>2. 返回最多 100 行数据<br>3. 返回列名和数据类型 |

#### 6.3.3 字段管理测试

| 用例ID | TC-DM-013 |
|--------|-------------|
| **用例名称** | 配置字段为维度 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 PUT /api/v1/datasets/{id}/fields/{fieldId}<br>2. 设置 type="dimension" |
| **预期结果** | 1. 返回状态码 200<br>2. 字段类型已更新为维度 |

| 用例ID | TC-DM-014 |
|--------|-------------|
| **用例名称** | 配置字段为度量 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 PUT /api/v1/datasets/{id}/fields/{fieldId}<br>2. 设置 type="measure" |
| **预期结果** | 1. 返回状态码 200<br>2. 字段类型已更新为度量 |

| 用例ID | TC-DM-015 |
|--------|-------------|
| **用例名称** | 批量更新字段 |
| **优先级** | P1 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 PATCH /api/v1/datasets/{id}/fields<br>2. 批量更新多个字段 |
| **预期结果** | 1. 返回状态码 200<br>2. 返回成功更新的字段 ID 列表<br>3. 返回失败项的错误详情 |

#### 6.3.4 计算字段测试

| 用例ID | TC-DM-016 |
|--------|-------------|
| **用例名称** | 创建计算字段 - 简单表达式 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 调用 POST /api/v1/datasets/{id}/fields<br>2. 创建计算字段 |
| **请求体** | ```json {"name":"profit","displayName":"利润","expression":"[price] * [quantity]","type":"measure","dataType":"number"}``` |
| **预期结果** | 1. 返回状态码 201<br>2. 计算字段已创建<br>3. 标记为 isComputed=true |

| 用例ID | TC-DM-017 |
|--------|-------------|
| **用例名称** | 创建计算字段 - 使用函数 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 创建使用 ROUND 函数的计算字段 |
| **请求体** | ```json {"name":"rounded_total","expression":"ROUND([total_amount], 2)","type":"measure"}``` |
| **预期结果** | 1. 创建成功<br>2. 查询数据时计算字段值正确 |

| 用例ID | TC-DM-018 |
|--------|-------------|
| **用例名称** | 创建计算字段 - 无效表达式 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 创建语法错误的表达式 |
| **请求体** | ```json {"name":"invalid","expression":"[price + ","type":"measure"}``` |
| **预期结果** | 1. 返回状态码 400<br>2. 返回表达式语法错误信息 |

| 用例ID | TC-DM-019 |
|--------|-------------|
| **用例名称** | 查询数据 - 计算字段正确计算 |
| **优先级** | P0 |
| **前置条件** | 计算字段已创建 |
| **测试步骤** | 1. 查询数据集数据<br>2. 检查计算字段值 |
| **预期结果** | 1. 计算字段值正确计算<br>2. 例如 profit = price * quantity |

| 用例ID | TC-DM-020 |
|--------|-------------|
| **用例名称** | 删除计算字段 - 原始字段不可删除 |
| **优先级** | P0 |
| **前置条件** | 数据集有原始字段和计算字段 |
| **测试步骤** | 1. 尝试删除原始字段 |
| **预期结果** | 1. 返回状态码 400<br>2. 返回"不能删除原始字段"错误 |

#### 6.3.5 查询安全控制测试

| 用例ID | TC-DM-021 |
|--------|-------------|
| **用例名称** | 拒绝危险 SQL - DELETE 语句 |
| **优先级** | P0 |
| **前置条件** | 数据源已创建 |
| **测试步骤** | 1. 创建包含 DELETE 的数据集 |
| **预期结果** | 1. 返回验证错误<br>2. 不执行 SQL |

| 用例ID | TC-DM-022 |
|--------|-------------|
| **用例名称** | 拒绝危险 SQL - DROP 语句 |
| **优先级** | P0 |
| **前置条件** | 数据源已创建 |
| **测试步骤** | 1. 创建包含 DROP 的数据集 |
| **预期结果** | 1. 返回验证错误<br>2. 不执行 SQL |

| 用例ID | TC-DM-023 |
|--------|-------------|
| **用例名称** | 查询超时保护 |
| **优先级** | P1 |
| **前置条件** | 数据集查询超时配置为 10s |
| **测试步骤** | 1. 执行耗时超过 10s 的查询 |
| **预期结果** | 1. 返回超时错误<br>2. 查询被中止 |

| 用例ID | TC-DM-024 |
|--------|-------------|
| **用例名称** | 分页边界保护 |
| **优先级** | P1 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 请求 pageSize=10000 |
| **预期结果** | 1. 应用最大分页限制<br>2. 返回实际应用的 pageSize |

---

### 6.4 报表设计器测试

#### 6.4.1 设计器基础操作测试

| 用例ID | TC-RD-001 |
|--------|-------------|
| **用例名称** | 打开报表设计器 |
| **优先级** | P0 |
| **前置条件** | 用户已登录 |
| **测试步骤** | 1. 导航到 /report/designer<br>2. 检查页面元素 |
| **预期结果** | 1. 画布正确渲染<br>2. 工具栏可见<br>3. 属性面板可见 |

| 用例ID | TC-RD-002 |
|--------|-------------|
| **用例名称** | 单元格选择和编辑 |
| **优先级** | P0 |
| **前置条件** | 设计器已打开 |
| **测试步骤** | 1. 点击单元格<br>2. 输入文本<br>3. 按 Enter 确认 |
| **预期结果** | 1. 单元格被选中高亮<br>2. 文本显示在单元格中 |

| 用例ID | TC-RD-003 |
|--------|-------------|
| **用例名称** | 单元格合并 |
| **优先级** | P0 |
| **前置条件** | 设计器已打开 |
| **测试步骤** | 1. 选择 2x2 的单元格区域<br>2. 点击合并按钮 |
| **预期结果** | 1. 单元格合并为一个大单元格<br>2. 左上角值保留 |

| 用例ID | TC-RD-004 |
|--------|-------------|
| **用例名称** | 单元格样式设置 |
| **优先级** | P0 |
| **前置条件** | 单元格已选中 |
| **测试步骤** | 1. 在属性面板设置字体大小 16<br>2. 设置背景颜色为蓝色<br>3. 设置字体颜色为白色 |
| **预期结果** | 1. 样式立即应用到单元格<br>2. 视觉效果正确 |

| 用例ID | TC-RD-005 |
|--------|-------------|
| **用例名称** | 键盘快捷键 - 复制粘贴 |
| **优先级** | P1 |
| **前置条件** | 设计器已打开，单元格有内容 |
| **测试步骤** | 1. 选中单元格<br>2. 按 Ctrl+C<br>3. 选中目标单元格<br>4. 按 Ctrl+V |
| **预期结果** | 1. 内容被复制到目标单元格<br>2. 样式一同复制 |

| 用例ID | TC-RD-006 |
|--------|-------------|
| **用例名称** | 键盘快捷键 - 撤销/重做 |
| **优先级** | P1 |
| **前置条件** | 设计器已打开 |
| **测试步骤** | 1. 输入内容<br>2. 按 Ctrl+Z<br>3. 按 Ctrl+Y |
| **预期结果** | 1. 撤销后内容消失<br>2. 重做后内容恢复 |

#### 6.4.2 数据绑定测试

| 用例ID | TC-RD-007 |
|--------|-------------|
| **用例名称** | 单元格绑定数据源字段 |
| **优先级** | P0 |
| **前置条件** | 数据源和数据集已创建 |
| **测试步骤** | 1. 选中单元格<br>2. 打开数据绑定面板<br>3. 选择数据集<br>4. 选择维度字段 |
| **预期结果** | 1. 绑定成功<br>2. 单元格显示字段名占位符<br>3. 预览时显示实际数据 |

| 用例ID | TC-RD-008 |
|--------|-------------|
| **用例名称** | 单元格绑定度量并聚合 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 选中单元格<br>2. 绑定度量字段<br>3. 选择 SUM 聚合函数 |
| **预期结果** | 1. 绑定成功<br>2. 预览时显示聚合结果 |

| 用例ID | TC-RD-009 |
|--------|-------------|
| **用例名称** | 表达式编辑器使用 |
| **优先级** | P1 |
| **前置条件** | 设计器已打开 |
| **测试步骤** | 1. 打开表达式编辑器<br>2. 输入复杂表达式<br>3. 点击验证 |
| **预期结果** | 1. 语法高亮正常<br>2. 自动完成提示字段名<br>3. 验证结果显示 |

#### 6.4.3 报表保存与加载测试

| 用例ID | TC-RD-010 |
|--------|-------------|
| **用例名称** | 保存新报表 |
| **优先级** | P0 |
| **前置条件** | 设计器已创建报表 |
| **测试步骤** | 1. 点击保存按钮<br>2. 输入报表名称<br>3. 确认保存 |
| **预期结果** | 1. 保存成功<br>2. 返回报表 ID<br>3. 显示成功提示 |

| 用例ID | TC-RD-011 |
|--------|-------------|
| **用例名称** | 加载已保存报表 |
| **优先级** | P0 |
| **前置条件** | 报表已保存 |
| **测试步骤** | 1. 从报表列表选择报表<br>2. 点击编辑 |
| **预期结果** | 1. 报表正确加载<br>2. 所有单元格和样式恢复<br>3. 数据绑定保持 |

| 用例ID | TC-RD-012 |
|--------|-------------|
| **用例名称** | 自动保存触发 |
| **优先级** | P1 |
| **前置条件** | 报表已修改，30秒未保存 |
| **测试步骤** | 1. 修改报表内容<br>2. 等待 30 秒 |
| **预期结果** | 1. 自动保存触发<br>2. 显示"自动保存"提示 |

---

### 6.5 报表渲染与预览测试

#### 6.5.1 报表预览测试

| 用例ID | TC-RR-001 |
|--------|-------------|
| **用例名称** | 报表预览 - 数据正确渲染 |
| **优先级** | P0 |
| **前置条件** | 报表已创建并有数据绑定 |
| **测试步骤** | 1. 点击预览按钮<br>2. 检查数据渲染 |
| **预期结果** | 1. 预览页面打开<br>2. 所有数据绑定单元格显示实际数据<br>3. 样式正确渲染 |

| 用例ID | TC-RR-002 |
|--------|-------------|
| **用例名称** | 报表预览 - 带参数过滤 |
| **优先级** | P1 |
| **前置条件** | 报表有参数配置 |
| **测试步骤** | 1. 打开预览<br>2. 输入参数值<br>3. 查看结果 |
| **预期结果** | 1. 数据按参数过滤<br>2. 参数值显示在标题 |

| 用例ID | TC-RR-003 |
|--------|-------------|
| **用例名称** | 报表预览 - 刷新数据 |
| **优先级** | P1 |
| **前置条件** | 预览已打开 |
| **测试步骤** | 1. 点击刷新按钮 |
| **预期结果** | 1. 数据重新加载<br>2. 显示最新数据 |

#### 6.5.2 分页测试

| 用例ID | TC-RR-004 |
|--------|-------------|
| **用例名称** | 报表分页 - 大数据集 |
| **优先级** | P1 |
| **前置条件** | 报表数据超过 50 行 |
| **测试步骤** | 1. 预览报表<br>2. 检查分页控件 |
| **预期结果** | 1. 显示分页控件<br>2. 每页显示 50 行<br>3. 页码显示正确 |

| 用例ID | TC-RR-005 |
|--------|-------------|
| **用例名称** | 报表分页 - 翻页操作 |
| **优先级** | P1 |
| **前置条件** | 报表有多页数据 |
| **测试步骤** | 1. 点击下一页<br>2. 点击上一页<br>3. 跳转到最后一页 |
| **预期结果** | 1. 翻页正确<br>2. 数据正确加载 |

#### 6.5.3 打印预览测试

| 用例ID | TC-RR-006 |
|--------|-------------|
| **用例名称** | 打印预览 - A4 纵向 |
| **优先级** | P1 |
| **前置条件** | 报表已创建 |
| **测试步骤** | 1. 打开打印预览<br>2. 选择 A4 纵向 |
| **预期结果** | 1. 页面按 A4 大小显示<br>2. 边距线可见<br>3. 分页正确 |

---

### 6.6 报表导出测试

#### 6.6.1 导出功能测试

| 用例ID | TC-RE-001 |
|--------|-------------|
| **用例名称** | 导出 PDF |
| **优先级** | P1 |
| **前置条件** | 报表已预览 |
| **测试步骤** | 1. 点击导出按钮<br>2. 选择 PDF 格式<br>3. 确认导出 |
| **预期结果** | 1. 导出任务创建<br>2. 进度显示<br>3. PDF 文件下载成功 |

| 用例ID | TC-RE-002 |
|--------|-------------|
| **用例名称** | 导出 Excel |
| **优先级** | P1 |
| **前置条件** | 报表已预览 |
| **测试步骤** | 1. 点击导出按钮<br>2. 选择 Excel 格式<br>3. 确认导出 |
| **预期结果** | 1. Excel 文件下载成功<br>2. 数据完整<br>3. 格式保留 |

| 用例ID | TC-RE-003 |
|--------|-------------|
| **用例名称** | 导出 - 大数据量 |
| **优先级** | P2 |
| **前置条件** | 报表有 10000+ 行数据 |
| **测试步骤** | 1. 导出为 Excel |
| **预期结果** | 1. 导出成功<br>2. 内存不溢出<br>3. 文件完整 |

---

### 6.7 BI 仪表盘测试

#### 6.7.1 仪表盘设计器测试

| 用例ID | TC-BD-001 |
|--------|-------------|
| **用例名称** | 创建新仪表盘 |
| **优先级** | P0 |
| **前置条件** | 用户已登录 |
| **测试步骤** | 1. 点击创建仪表盘<br>2. 检查画布和组件面板 |
| **预期结果** | 1. 空白画布显示<br>2. 组件面板可见<br>3. 属性面板可见 |

| 用例ID | TC-BD-002 |
|--------|-------------|
| **用例名称** | 拖放组件到画布 |
| **优先级** | P0 |
| **前置条件** | 仪表盘设计器已打开 |
| **测试步骤** | 1. 从组件面板拖动文本卡片<br>2. 放置到画布 |
| **预期结果** | 1. 组件添加成功<br>2. 组件吸附到网格<br>3. 组件被选中 |

| 用例ID | TC-BD-003 |
|--------|-------------|
| **用例名称** | 组件数据绑定 |
| **优先级** | P0 |
| **前置条件** | 组件已添加，数据集已创建 |
| **测试步骤** | 1. 选中图表组件<br>2. 配置数据绑定<br>3. 选择数据集和字段 |
| **预期结果** | 1. 绑定成功<br>2. 图表显示数据 |

| 用例ID | TC-BD-004 |
|--------|-------------|
| **用例名称** | 图层管理 - 重新排序 |
| **优先级** | P1 |
| **前置条件** | 多个组件已添加 |
| **测试步骤** | 1. 打开图层面板<br>2. 拖动图层改变顺序 |
| **预期结果** | 1. 图层顺序更新<br>2. 画布上叠加顺序改变 |

| 用例ID | TC-BD-005 |
|--------|-------------|
| **用例名称** | 保存仪表盘 |
| **优先级** | P0 |
| **前置条件** | 仪表盘已设计 |
| **测试步骤** | 1. 点击保存按钮 |
| **预期结果** | 1. 保存成功<br>2. 返回仪表盘 ID |

| 用例ID | TC-BD-006 |
|--------|-------------|
| **用例名称** | 加载已保存仪表盘 |
| **优先级** | P0 |
| **前置条件** | 仪表盘已保存 |
| **测试步骤** | 1. 从列表选择仪表盘<br>2. 点击编辑 |
| **预期结果** | 1. 所有组件正确恢复<br>2. 数据绑定保持<br>3. 样式保持 |

#### 6.7.2 仪表盘预览测试

| 用例ID | TC-BD-007 |
|--------|-------------|
| **用例名称** | 仪表盘预览模式 |
| **优先级** | P1 |
| **前置条件** | 仪表盘已设计 |
| **测试步骤** | 1. 点击预览按钮 |
| **预期结果** | 1. 进入预览模式<br>2. 设计元素隐藏<br>3. 数据加载正确 |

---

### 6.8 图表编辑器测试

#### 6.8.1 图表类型测试

| 用例ID | TC-CE-001 |
|--------|-------------|
| **用例名称** | 选择柱状图 |
| **优先级** | P0 |
| **前置条件** | 图表编辑器已打开 |
| **测试步骤** | 1. 选择柱状图类型<br>2. 配置数据和轴 |
| **预期结果** | 1. 图表类型应用成功<br>2. 预览显示柱状图 |

| 用例ID | TC-CE-002 |
|--------|-------------|
| **用例名称** | 选择折线图 |
| **优先级** | P0 |
| **前置条件** | 图表编辑器已打开 |
| **测试步骤** | 1. 选择折线图类型<br>2. 配置数据 |
| **预期结果** | 1. 图表类型应用成功<br>2. 预览显示折线图 |

| 用例ID | TC-CE-003 |
|--------|-------------|
| **用例名称** | 选择饼图 |
| **优先级** | P0 |
| **前置条件** | 图表编辑器已打开 |
| **测试步骤** | 1. 选择饼图类型<br>2. 配置维度和度量 |
| **预期结果** | 1. 图表类型应用成功<br>2. 预览显示饼图 |

#### 6.8.2 图表数据配置测试

| 用例ID | TC-CE-004 |
|--------|-------------|
| **用例名称** | 图表绑定数据集 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 选择数据集作为数据源<br>2. 映射维度和度量 |
| **预期结果** | 1. 绑定成功<br>2. 图表显示实际数据 |

| 用例ID | TC-CE-005 |
|--------|-------------|
| **用例名称** | 图表实时预览更新 |
| **优先级** | P1 |
| **前置条件** | 图表已配置 |
| **测试步骤** | 1. 修改图表属性<br>2. 观察预览变化 |
| **预期结果** | 1. 预览实时更新<br>2. 更新流畅无闪烁 |

#### 6.8.3 图表交互测试

| 用例ID | TC-CE-006 |
|--------|-------------|
| **用例名称** | 图表悬停提示 |
| **优先级** | P1 |
| **前置条件** | 图表已渲染 |
| **测试步骤** | 1. 鼠标悬停在数据点上 |
| **预期结果** | 1. 显示提示框<br>2. 提示内容正确 |

| 用例ID | TC-CE-007 |
|--------|-------------|
| **用例名称** | 图例切换 |
| **优先级** | P1 |
| **前置条件** | 图表有多个系列 |
| **测试步骤** | 1. 点击图例项 |
| **预期结果** | 1. 对应系列显示/隐藏<br>2. 图表重新计算范围 |

---

### 6.9 查询缓存测试

#### 6.9.1 缓存功能测试

| 用例ID | TC-QC-001 |
|--------|-------------|
| **用例名称** | Redis 缓存命中 |
| **优先级** | P1 |
| **前置条件** | Redis 已启用 |
| **测试步骤** | 1. 第一次查询数据集<br>2. 第二次相同查询 |
| **预期结果** | 1. 第二次查询命中缓存<br>2. 响应时间显著减少 |

| 用例ID | TC-QC-002 |
|--------|-------------|
| **用例名称** | 缓存租户隔离 |
| **优先级** | P0 |
| **前置条件** | 多租户数据已准备 |
| **测试步骤** | 1. tenant-1 查询数据<br>2. tenant-2 相同查询 |
| **预期结果** | 1. 两次查询结果不同<br>2. 无跨租户数据泄露 |

| 用例ID | TC-QC-003 |
|--------|-------------|
| **用例名称** | Redis 不可用时降级 |
| **优先级** | P1 |
| **前置条件** | Redis 服务停止 |
| **测试步骤** | 1. 查询数据集 |
| **预期结果** | 1. 查询正常返回<br>2. 记录降级日志 |

| 用例ID | TC-QC-004 |
|--------|-------------|
| **用例名称** | 数据更新后缓存失效 |
| **优先级** | P1 |
| **前置条件** | 数据已缓存 |
| **测试步骤** | 1. 更新数据源配置<br>2. 再次查询 |
| **预期结果** | 1. 缓存被清理<br>2. 返回新数据 |

---

### 6.10 前端功能可用性测试

#### 6.10.1 核心入口测试

| 用例ID | TC-FFA-001 |
|--------|-------------|
| **用例名称** | 核心功能导航可见 |
| **优先级** | P0 |
| **前置条件** | 用户已登录 |
| **测试步骤** | 1. 检查主导航菜单 |
| **预期结果** | 1. 报表设计器入口可见<br>2. 仪表盘入口可见<br>3. 图表编辑器入口可见 |

| 用例ID | TC-FFA-002 |
|--------|-------------|
| **用例名称** | 直接访问核心路由 |
| **优先级** | P0 |
| **前置条件** | 用户已登录 |
| **测试步骤** | 1. 直接输入 /report/designer URL |
| **预期结果** | 1. 页面正确渲染<br>2. 无空白页面 |

#### 6.10.2 错误处理测试

| 用例ID | TC-FFA-003 |
|--------|-------------|
| **用例名称** | API 错误显示后端消息 |
| **优先级** | P0 |
| **前置条件** | 触发 API 错误 |
| **测试步骤** | 1. 执行无效操作（如删除不存在的资源） |
| **预期结果** | 1. 显示后端返回的错误消息<br>2. 不显示通用错误 |

| 用例ID | TC-FFA-004 |
|--------|-------------|
| **用例名称** | 网络错误优雅处理 |
| **优先级** | P1 |
| **前置条件** | 断开网络 |
| **测试步骤** | 1. 执行需要网络的操作 |
| **预期结果** | 1. 显示网络错误提示<br>2. 提供重试选项 |

---

### 6.11 系统集成与兼容性测试

#### 6.11.1 迁移兼容性测试

| 用例ID | TC-MC-001 |
|--------|-------------|
| **用例名称** | 遗留路由 /jmreport/ 兼容 |
| **优先级** | P1 |
| **前置条件** | 无 |
| **测试步骤** | 1. 访问 /jmreport/list |
| **预期结果** | 1. 页面正常显示<br>2. 无需 UI 更改 |

| 用例ID | TC-MC-002 |
|--------|-------------|
| **用例名称** | 遗留路由 /drag/ 兼容 |
| **优先级** | P1 |
| **前置条件** | 无 |
| **测试步骤** | 1. 访问 /drag/list |
| **预期结果** | 1. 仪表盘页面正常显示 |

#### 6.11.2 CORS 配置测试

| 用例ID | TC-EI-001 |
|--------|-------------|
| **用例名称** | CORS 允许配置的来源 |
| **优先级** | P1 |
| **前置条件** | CORS 已配置 |
| **测试步骤** | 1. 从允许的来源发起跨域请求 |
| **预期结果** | 1. 请求成功<br>2. CORS 头正确返回 |

| 用例ID | TC-EI-002 |
|--------|-------------|
| **用例名称** | CORS 拒绝未配置的来源 |
| **优先级** | P1 |
| **前置条件** | CORS 已配置 |
| **测试步骤** | 1. 从未配置的来源发起跨域请求 |
| **预期结果** | 1. 请求被拒绝 |

---

### 6.12 性能测试

#### 6.12.1 响应时间测试

| 用例ID | TC-PERF-001 |
|--------|-------------|
| **用例名称** | 数据集查询响应时间 |
| **优先级** | P1 |
| **前置条件** | 测试数据 10000 条 |
| **测试步骤** | 1. 执行数据集查询<br>2. 测量响应时间 |
| **预期结果** | 1. 响应时间 < 2 秒 |

| 用例ID | TC-PERF-002 |
|--------|-------------|
| **用例名称** | 报表预览响应时间 |
| **优先级** | P1 |
| **前置条件** | 报表有 1000+ 单元格 |
| **测试步骤** | 1. 打开报表预览<br>2. 测量加载时间 |
| **预期结果** | 1. 加载时间 < 3 秒 |

| 用例ID | TC-PERF-003 |
|--------|-------------|
| **用案ID** | TC-PERF-003 |
| **用例名称** | 仪表盘加载时间 |
| **优先级** | P1 |
| **前置条件** | 仪表盘有 50 个组件 |
| **测试步骤** | 1. 打开仪表盘<br>2. 测量加载时间 |
| **预期结果** | 1. 加载时间 < 5 秒 |

#### 6.12.2 并发测试

| 用例ID | TC-PERF-004 |
|--------|-------------|
| **用例名称** | 并发查询测试 |
| **优先级** | P1 |
| **前置条件** | 测试环境已准备 |
| **测试步骤** | 1. 100 个并发用户查询数据集 |
| **预期结果** | 1. 所有请求成功<br>2. 平均响应时间 < 5 秒<br>3. 无错误响应 |

#### 6.12.3 大数据量测试

| 用例ID | TC-PERF-005 |
|--------|-------------|
| **用例名称** | 大数据集分页查询 |
| **优先级** | P2 |
| **前置条件** | 数据集有 100000 条记录 |
| **测试步骤** | 1. 翻页查询最后一页 |
| **预期结果** | 1. 查询成功<br>2. 响应时间 < 3 秒 |

---

### 6.13 安全测试

#### 6.13.1 SQL 注入测试

| 用例ID | TC-SEC-001 |
|--------|-------------|
| **用例名称** | 数据集查询 SQL 注入 |
| **优先级** | P0 |
| **前置条件** | 数据集已创建 |
| **测试步骤** | 1. 在过滤条件中输入 SQL 注入字符串 |
| **测试数据** | `' OR '1'='1`; `'; DROP TABLE users;--` |
| **预期结果** | 1. 注入攻击被阻止<br>2. 无 SQL 错误暴露<br>3. 数据安全 |

#### 6.13.2 XSS 测试

| 用例ID | TC-SEC-002 |
|--------|-------------|
| **用例名称** | 报表内容 XSS |
| **优先级** | P0 |
| **前置条件** | 设计器已打开 |
| **测试步骤** | 1. 在单元格输入 XSS 脚本<br>2. 预览报表 |
| **测试数据** | `<script>alert('XSS')</script>` |
| **预期结果** | 1. 脚本不执行<br>2. 内容被正确转义 |

#### 6.13.3 越权访问测试

| 用例ID | TC-SEC-003 |
|--------|-------------|
| **用例名称** | 水平越权 - 访问其他用户数据 |
| **优先级** | P0 |
| **前置条件** | 两个用户在同一租户 |
| **测试步骤** | 1. user1 创建报表<br>2. user2 尝试访问 user1 的报表 |
| **预期结果** | 1. 根据权限配置决定访问结果 |

| 用例ID | TC-SEC-004 |
|--------|-------------|
| **用例名称** | 垂直越权 - 普通用户执行管理员操作 |
| **优先级** | P0 |
| **前置条件** | 普通用户已登录 |
| **测试步骤** | 1. 普通用户尝试调用管理员 API |
| **预期结果** | 1. 返回 403 Forbidden<br>2. 操作被阻止 |

#### 6.13.4 敏感信息泄露测试

| 用例ID | TC-SEC-005 |
|--------|-------------|
| **用例名称** | 数据源密码不返回 |
| **优先级** | P0 |
| **前置条件** | 数据源已创建 |
| **测试步骤** | 1. 获取数据源详情 API |
| **预期结果** | 1. 响应中不包含密码字段<br>2. 密码字段为 null 或不存在 |

| 用例ID | TC-SEC-006 |
|--------|-------------|
| **用例名称** | 错误信息不含敏感数据 |
| **优先级** | P0 |
| **前置条件** | 无 |
| **测试步骤** | 1. 触发各种错误场景<br>2. 检查错误响应 |
| **预期结果** | 1. 错误信息不含数据库连接串<br>2. 不含内部路径<br>3. 不含堆栈跟踪 |

---

## 7. 测试执行计划

### 7.1 测试阶段

| 阶段 | 内容 | 持续时间 | 负责人 |
|------|------|----------|--------|
| **测试准备** | 环境搭建、数据准备、用例评审 | 2 天 | 测试组 |
| **冒烟测试** | 核心功能 P0 用例 | 1 天 | 测试组 |
| **功能测试** | 全部功能用例 | 5 天 | 测试组 |
| **集成测试** | API 集成、数据流测试 | 3 天 | 测试组 |
| **性能测试** | 性能基准测试 | 2 天 | 测试组 |
| **安全测试** | 安全漏洞扫描和测试 | 2 天 | 安全组 |
| **回归测试** | 缺陷修复后回归 | 2 天 | 测试组 |
| **UAT 测试** | 用户验收测试 | 3 天 | 用户代表 |

### 7.2 测试进度安排

```
Week 1: 测试准备 + 冒烟测试 + 功能测试开始
Week 2: 功能测试继续 + 集成测试
Week 3: 性能测试 + 安全测试
Week 4: 回归测试 + UAT
```

### 7.3 每日测试活动

| 活动 | 时间 | 内容 |
|------|------|------|
| 晨会 | 9:30 | 同步测试进度、阻塞问题 |
| 测试执行 | 10:00-18:00 | 执行测试用例、记录缺陷 |
| 缺陷评审 | 18:00 | 每日缺陷评审会议 |
| 日报提交 | 19:00 | 提交测试日报 |

---

## 8. 缺陷管理

### 8.1 缺陷严重程度

| 等级 | 定义 | 示例 | 处理时限 |
|------|------|------|----------|
| **致命 (Critical)** | 系统崩溃、数据丢失、安全漏洞 | SQL 注入、数据泄露 | 4 小时 |
| **严重 (Major)** | 核心功能不可用、主要流程中断 | 无法登录、无法保存报表 | 8 小时 |
| **一般 (Normal)** | 功能异常但有变通方案 | 分页显示错误、提示不清晰 | 24 小时 |
| **轻微 (Minor)** | UI 问题、文案错误 | 样式偏差、错别字 | 72 小时 |
| **建议 (Suggestion)** | 优化建议 | 交互改进、性能优化 | 下版本 |

### 8.2 缺陷状态流转

```
新建 → 确认 → 分配 → 修复中 → 已修复 → 验证中 → 已关闭
                  ↓
               无法复现 → 已关闭
                  ↓
               暂不处理 → 延期
```

### 8.3 缺陷报告模板

```markdown
## 缺陷标题
[模块] 简短描述

## 环境信息
- 测试环境: [测试/预发布]
- 浏览器: [Chrome 120]
- 操作系统: [Windows 11]

## 前置条件
1. xxx
2. xxx

## 复现步骤
1. xxx
2. xxx
3. xxx

## 预期结果
xxx

## 实际结果
xxx

## 附件
- 截图
- 日志
- 请求/响应

## 影响范围
描述此缺陷对其他功能的影响
```

---

## 9. 测试报告

### 9.1 日报模板

```markdown
# 测试日报 - YYYY-MM-DD

## 测试概况
- 计划执行用例: XX
- 实际执行用例: XX
- 通过用例: XX
- 失败用例: XX
- 阻塞用例: XX

## 新增缺陷
| ID | 标题 | 严重程度 | 状态 |
|----|------|----------|------|
| XX | XXX | Major | New |

## 缺陷处理情况
- 新增: XX
- 已修复: XX
- 已验证: XX
- 待修复: XX

## 风险与阻塞
- xxx

## 明日计划
- xxx
```

### 9.2 周报模板

```markdown
# 测试周报 - 第 X 周

## 本周完成情况
- 测试进度: XX%
- 用例执行率: XX%
- 缺陷发现: XX
- 缺陷修复: XX

## 质量指标
| 指标 | 目标 | 实际 |
|------|------|------|
| P0 用例通过率 | 100% | XX% |
| 缺陷修复率 | 95% | XX% |
| 严重缺陷数 | 0 | XX |

## 主要问题与风险
1. xxx
2. xxx

## 下周计划
1. xxx
2. xxx
```

### 9.3 最终测试报告模板

```markdown
# GoReport 系统测试报告

## 1. 测试概述
- 测试版本: vX.X.X
- 测试周期: YYYY-MM-DD ~ YYYY-MM-DD
- 测试人员: XXX

## 2. 测试范围
[列出测试覆盖的模块]

## 3. 测试结果汇总
| 模块 | 用例数 | 通过 | 失败 | 通过率 |
|------|--------|------|------|--------|
| 认证授权 | XX | XX | XX | XX% |
| 数据源管理 | XX | XX | XX | XX% |
| ... | ... | ... | ... | ... |
| **总计** | **XX** | **XX** | **XX** | **XX%** |

## 4. 缺陷统计
| 严重程度 | 发现 | 已修复 | 待修复 |
|----------|------|--------|--------|
| Critical | XX | XX | XX |
| Major | XX | XX | XX |
| Normal | XX | XX | XX |
| Minor | XX | XX | XX |

## 5. 性能测试结果
| 场景 | 目标 | 实际 | 结果 |
|------|------|------|------|
| 数据集查询 | < 2s | X.X s | Pass/Fail |
| 报表预览 | < 3s | X.X s | Pass/Fail |

## 6. 安全测试结果
| 检查项 | 结果 |
|--------|------|
| SQL 注入 | Pass/Fail |
| XSS 攻击 | Pass/Fail |
| 越权访问 | Pass/Fail |

## 7. 遗留问题
| ID | 描述 | 影响 | 计划 |
|----|------|------|------|
| XX | XXX | XXX | 下版本 |

## 8. 测试结论
[ ] 建议发布
[ ] 有条件发布（附条件说明）
[ ] 不建议发布（附原因）

## 9. 附录
- 测试用例清单
- 缺陷清单
- 性能测试详细报告
```

---

## 附录 A: 测试用例清单统计

| 模块 | P0 | P1 | P2 | P3 | 总计 |
|------|----|----|----|----|------|
| 认证与授权 | 10 | 2 | 0 | 0 | 12 |
| 数据源管理 | 12 | 6 | 0 | 0 | 18 |
| 数据集管理 | 16 | 8 | 0 | 0 | 24 |
| 报表设计器 | 8 | 4 | 0 | 0 | 12 |
| 报表渲染与预览 | 4 | 6 | 0 | 0 | 10 |
| 报表导出 | 0 | 3 | 1 | 0 | 4 |
| BI 仪表盘 | 6 | 2 | 0 | 0 | 8 |
| 图表编辑器 | 6 | 2 | 0 | 0 | 8 |
| 查询缓存 | 2 | 3 | 0 | 0 | 5 |
| 前端功能可用性 | 4 | 1 | 0 | 0 | 5 |
| 系统集成与兼容性 | 0 | 4 | 0 | 0 | 4 |
| 性能测试 | 0 | 4 | 1 | 0 | 5 |
| 安全测试 | 8 | 0 | 0 | 0 | 8 |
| **总计** | **76** | **45** | **2** | **0** | **123** |

---

## 附录 B: 自动化测试脚本示例

### B.1 登录 API 测试 (Go)

```go
package test

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/stretchr/testify/assert"
)

func TestLogin_Success(t *testing.T) {
    router := setupTestRouter()
    
    body := map[string]string{
        "username": "user1",
        "password": "User1@123",
    }
    jsonBody, _ := json.Marshal(body)
    
    req, _ := http.NewRequest("POST", "/api/v1/auth/login", bytes.NewBuffer(jsonBody))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusOK, w.Code)
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    assert.NotEmpty(t, response["token"])
}

func TestLogin_InvalidPassword(t *testing.T) {
    router := setupTestRouter()
    
    body := map[string]string{
        "username": "user1",
        "password": "wrongpassword",
    }
    jsonBody, _ := json.Marshal(body)
    
    req, _ := http.NewRequest("POST", "/api/v1/auth/login", bytes.NewBuffer(jsonBody))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusUnauthorized, w.Code)
}
```

### B.2 数据源 CRUD 测试 (Go)

```go
func TestCreateDatasource_Success(t *testing.T) {
    router := setupTestRouter()
    token := getTestToken(t, router)
    
    body := map[string]interface{}{
        "name":     "test-mysql",
        "type":     "mysql",
        "host":     "localhost",
        "port":     3306,
        "database": "test_db",
        "username": "root",
        "password": "root",
    }
    jsonBody, _ := json.Marshal(body)
    
    req, _ := http.NewRequest("POST", "/api/v1/datasources", bytes.NewBuffer(jsonBody))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+token)
    
    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusCreated, w.Code)
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    assert.NotEmpty(t, response["id"])
    assert.Empty(t, response["password"]) // 密码不应返回
}
```

### B.3 前端组件测试 (TypeScript/Vitest)

```typescript
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import Login from '@/views/Login.vue'

describe('Login Component', () => {
  it('should show validation error when username is empty', async () => {
    const wrapper = mount(Login)
    
    await wrapper.find('input[type="password"]').setValue('password')
    await wrapper.find('form').trigger('submit')
    
    expect(wrapper.find('.el-form-item__error').text()).toContain('请输入用户名')
  })
  
  it('should call login API with correct credentials', async () => {
    const mockLogin = vi.fn().mockResolvedValue({ token: 'test-token' })
    vi.mock('@/api/auth', () => ({ loginApi: { login: mockLogin } }))
    
    const wrapper = mount(Login)
    
    await wrapper.find('input[type="text"]').setValue('user1')
    await wrapper.find('input[type="password"]').setValue('User1@123')
    await wrapper.find('form').trigger('submit')
    
    expect(mockLogin).toHaveBeenCalledWith({
      username: 'user1',
      password: 'User1@123'
    })
  })
})
```

---

## 附录 C: 测试环境检查清单

- [ ] MySQL 服务运行正常
- [ ] Redis 服务运行正常（如需缓存测试）
- [ ] 后端服务启动成功
- [ ] 前端服务启动成功
- [ ] 测试数据库已初始化
- [ ] 测试用户已创建
- [ ] 测试数据源已配置
- [ ] 测试数据集已创建
- [ ] 网络连接正常
- [ ] 测试工具已安装（Postman、浏览器等）

---

**文档结束**

*此测试计划基于 all-requirements.md 生成，包含 123 个测试用例，覆盖 13 个测试模块。*
